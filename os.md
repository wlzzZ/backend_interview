+ **<font size = 5>线程和进程的区别</font>**

    进程是资源**分配**的独立单位;线程是资源**调度**的独立单位。一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是进程中的不同执行路径。线程有自己的堆栈和局部变量，没有自己独立的地址空间，一个线程死掉等于整个进程死掉，进程切换资源消耗较大，效率要差。


    - **进程**私有资源：地址空间，堆，全局变量，栈，寄存器
    - **进程**共享资源：代码段，公共数据，进程目录，进程ID
    - **线程**私有资源：线程栈，寄存器，程序寄存器
    - **线程**共享资源：堆，**地址空间**，全局变量，静态变量


+ **<font size = 5>多线程和多进程的对比，什么时候选择线程什么时候选择进程</font>**


    线程和进程对比表格汇总
    
    
    | 对比内容| 多进程 | 多线程|
    | :----------| :--------- |:--------- |
    |数据共享|数据共享复制，需要借助IPC(进程间通讯方式)|统一进程下，线程共享进程数据，数据分享简单| 
    |同步|数据是分开的，同步简单|数据共享，同步复杂|
    |内存CPU|占用内存多，切换复杂，CPU利用率低|占用内存少，切换简单，CPU利用率高|
    |创建销毁，切换|创建销毁，切换都比较复杂|创建销毁切换都比较简单|
    |编程难度|编程简单|编程复杂|
    |可靠性|进程间不会相互影响|一个线程挂掉将导致整个进程挂掉|
    |扩展性|适应于多核，多机分布式；一台机器不够用，扩展到多机上比较简单|适用于多核分布式|
    - 需要频繁创建销毁的优先使用线程
    - 需要进行大量计算的优先使用线程
    - 强相关的处理用线程，弱相关的处理用进程
    - 可能要扩展到多机分布的用进程，多核分布的用线程
+ **<font size = 5>进程的五状态模型</font>**

    ![avatar](./imgs/process_states.jpg)


    -   创建态：向进程申请一个空白的PCB(process control block),并向PCB中填写用于控制和管理进程的信息，为该进程分配运行时所必须的资源

    -   就绪态：进程已处于准备好的状态，及进程已经分配到所需的系统资源，只要获得CPU就可以执行
    -   执行态：进程获得CPU正在执行
    -   阻塞态：正在执行的进程，在执行过程中需要等待其它资源的到达，如：I/O请求，申请缓冲区失败等
    -   终止态：进程结束


+ **<font size = 5>进程间的通信方式以及优缺点</font>**

    主要包括无名管道，有名管道，信号，消息队列，共享内存，信号量和套接字

    1.  无名管道
        -   半双工的，具有固定的读端和写端
        -   它只能用于具有亲缘关系的进程之间的通信
        -   是一种特殊的文件， 不属于文件系统，只存在于内存中
        使用例子如下
        ```
        #include<stdio.h>
        #include<unistd.h>
        int main()
        {
            int fd[2];  // 两个文件描述符
            pid_t pid;
            char buff[20];

            if(pipe(fd) < 0)  // 创建管道
                printf("Create Pipe Error!\n"); 
            if((pid = fork()) < 0)  // 创建子进程
                printf("Fork Error!\n");
            else if(pid > 0)  // 父进程
            {
                close(fd[0]); // 关闭读端
                write(fd[1], "hello world\n", 12);
            }
            else
            {
                close(fd[1]); // 关闭写端
                read(fd[0], buff, 20);
                printf("%s", buff);
            }
 
            return 0;
        }
        ```
    2.  有名管道
        -   无关进程之间也可以交换数据
        -   它以一种特殊的设备文件形式存在系统中
        有名管道的通信类似于进程中使用文件来传输交换数据，在数据读出时，同时会清除数据，并且先进先出。以下两份代码演示不同进程间使用有名管道的通信方式
        ```
        //write_fifo.c
        #include<stdio.h>
        #include<stdlib.h>   // exit
        #include<fcntl.h>    // O_WRONLY
        #include<sys/stat.h>
        #include<time.h>     // time
        int main()
        {
            int fd;
            int n, i;
            char buf[1024];
            time_t tp;

            printf("I am %d process.\n", getpid()); // 说明进程ID
            if((fd = open("fifo1", O_WRONLY)) < 0) // 以写打开一个FIFO 
            {
                perror("Open FIFO Failed");
                exit(1);
            }
 
            for(i=0; i<10; ++i)
            {
                time(&tp);  // 取系统当前时间
                n=sprintf(buf,"Process %d's time is %s",getpid(),ctime(&tp));
                printf("Send message: %s", buf); // 打印
                if(write(fd, buf, n+1) < 0)  // 写入到FIFO中
                {
                    perror("Write FIFO Failed");
                    close(fd);
                    exit(1);
                }
                sleep(1);  // 休眠1秒
            }
            close(fd);  // 关闭FIFO文件
            return 0;
        }
        ```
        ```
        //read_fifo.c
        #include<stdio.h>
        #include<stdlib.h>
        #include<errno.h>
        #include<fcntl.h>
        #include<sys/stat.h>
        int main()
        {
            int fd;
            int len;
            char buf[1024];
            if(mkfifo("fifo1", 0666) < 0 && errno!=EEXIST) // 创建FIFO管道
                perror("Create FIFO Failed");

            if((fd = open("fifo1", O_RDONLY)) < 0)  // 以读打开FIFO
            {
                perror("Open FIFO Failed");
                exit(1);
            }
            while((len = read(fd, buf, 1024)) > 0) // 读取FIFO管道
                printf("Read message: %s", buf);
            close(fd);  // 关闭FIFO文件
            return 0;
        }
        ```


    3.  消息队列

        消息队列是消息的链接表，存放在内核中
        -   消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级
        -   消息队列独立于发生和接收进程。进程终止时，消息队列及其内容不会被删除
        -   消息队列可以实现消息的**随机查询**，消息不一定要以先进先出的次序读取

        函数原型
        ```
        #include <sys/msg.h>
        // 创建或打开消息队列：成功返回队列ID，失败返回-1
        int msgget(key_t key, int flag);
        // 添加消息：成功返回0，失败返回-1
        int msgsnd(int msqid, const void *ptr, size_t size, int flag);
        // 读取消息：成功返回消息数据的长度，失败返回-1
        int msgrcv(int msqid, void *ptr, size_t size, long type,int flag);
        // 控制消息队列：成功返回0，失败返回-1
        int msgctl(int msqid, int cmd, struct msqid_ds *buf);
        ```
    4. 信号量

        它是一个计数器，主要用于进程间的互斥和同步，而不是用于存储进程间通信数据

        -   信号量用于进程间同步，若要在进程间传递数据需要结合共享内存
        -   信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作

        最简单的信号量是只能取 0 和 1 的变量，这也是信号量最常见的一种形式，叫做二值信号量（Binary Semaphore）。而可以取多个正整数的信号量被称为通用信号量。Linux 下的信号量函数都是在通用的信号量数组上进行操作，而不是在一个单一的二值信号量上进行操作。
        ```
        #include <sys/sem.h>
        // 创建或获取一个信号量组：若成功返回信号量集ID，失败返回-1
        int semget(key_t key, int num_sems, int sem_flags);
        // 对信号量组进行操作，改变信号量的值：成功返回0，失败返回-1
        int semop(int semid, struct sembuf semoparray[], size_t numops);  
        // 控制信号量的相关信息
        int semctl(int semid, int sem_num, int cmd, ...);
        ```

    5.  共享内存

        共享内存指两个或多个进程共享一个给定的存储区
        -   共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
        -   因为多个进程可以同时操作，所以需要进行同步。
        -   信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

    6.  套接字
    
        它用于不同机器之间进程的通信
    

        各种进程间通信方式对比优缺点


        | 通信方式| 优缺点|
        | :- | :- |
        |无名管道|速度慢，容量有限，只有父子进程能通讯|
        |有名管道|任何进程间都能通讯，但速度慢|
        |消息队列|容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题，消息队列可以不再局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便，但是信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合。**此种方法不太常用**|
        |信号量|不能用来传递复杂消息，只能用来同步|
        |共享内存|利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。共享内存块提供了在任意数量的进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现。|


    通信方式的选择

    -   PIPE和FIFO(有名管道)用来实现进程间相互发送非常短小的、频率很高的消息，这两种方式通常适用于两个进程间的通信
    -   共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据；这种方法适用于多进程间的通信
    -   其他考虑用socket。主要应用在分布式开发中




+ **<font size = 5>线程间的通信方式</font>**


    线程间通信主要用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制
    -   锁机制：包括互斥锁，条件变量，读写锁；互斥锁提供了排它方式方式数据被并发的修改，读写锁允许多个线程同时读取共享数据，而对写操作是互斥的。条件变量可以以原子的方式阻塞线程，知道某个条件为真

    -   信号量机制
    -   信号机制




+ **<font size = 5>虚拟存储</font>**

    虚拟存储技术是指进程运行时，先将一部分装入内存，另一部分暂存磁盘，当要执行的指令或访问的数据不在内存中时，由操作系统自动将他们从磁盘调入内存中工作


+ **<font size = 5>分页分段和段页式存储</font>**


    连续分配方式会形成很多“碎片”，如果允许一个进程分散地装入到许多不相邻接的分区中，便可以充分地利用空间。
    

    1.  分页存储

        用户进程的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可以将用户程序的任意页放在内存任意块中，实现离散分配。程序的各个逻辑页面从0开始依次编号，每个页面内从0开始编址，称为页内地址；

       

        页表：分页系统中，允许将进程的每一页离散地存储在内存的任一物理块中，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页表，用于记录进程逻辑页面与内存物理页面之间的对应关系。页表的作用是实现从页号到物理块号的地址映射，地址空间有多少页，该页表里就登记多少行，且按逻辑页的顺序排列，形如：
        
        ![avatar](./imgs/page_table.png)

        程序中的逻辑地址由两部分组成：页号P和页内偏移量W。

         ![avatar](./imgs/page_store_logical.png)

        逻辑地址和物理地址转换，假设逻辑地址9126，页面大小4K,页表如下所示

        页号：9126/4096 = 2；页内偏移：9126%4096=934；物理地址 = 物理块号*页面大小 + 页内偏移

        ![avatar](./imgs/page_logical_phy.png)
    
    2.  分段存储


        页面是主存物理空间中划分出来的等长的固定区域。分页方式的优点是**页长固定，因而便于构造页表、易于管理，且不存在外碎片**。但分页方式的缺点是**页长与程序的逻辑大小不相关。例如，某个时刻一个子程序可能有一部分在主存中，另一部分则在辅存中。这不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦**。 
        
        另一种划分可寻址的存储空间的方法称为分段。段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。 段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。

        在段式存储中，地址空间被划分成了若干个段，虚拟地址由段号和段内地址组成，虚拟地址转换到物理地址通过段表来实现，每个程序设置一个段，段表的每一个表项至少包括三个字段：有效位（表面该段是否调入主存），段起始地址（该段在物理内存中的首地址），段长（该段的实际长度）

        ![avatar](./imgs/segment_logical_phy.jpg)
    

    3.  段页式存储


        段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。

        -   用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。
        -   用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的。但它又可按段实现共享和保护。
        
            ![avatar](./imgs/page_segment.jpg)

        -   段页式存储的逻辑结构，由三个参数表示：段号S,页号P,页内地址w

            ![avatar](./imgs/page_segment_logical.jpg)

        -   段表、页表、段表地址寄存器。为了进行地址转换，系统为每个作业建立一个段表，并且要为该作业段表中的每一个段建立一个页表。系统中有一个段表地址寄存器来指出作业的段表起始地址和段表长度。

            ![avatar](./imgs/page_segment_logical_phy.jpg)
        
        -   在段页式系统中，为了获得一条指令或数据，须三次访问内存。第一次访问是访问内存中的段表，从中取得段表始址；第二次访问是访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正从第二次访问所得的地址中，取出指令或数据。
    

    | 存储管理| 优点| 缺点|
    | :-- | :-- | :-- |
    |分页管理|页长固定，便于构造页表，易于管理且不存在外部碎片| 页长和程序逻辑大小不相关|
    |分段管理|段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享；段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间；方便编程，分段共享，分段保护，动态链接，动态增长|主存空间分配比较麻烦；容易在段间留下许多碎片，造成存储空间利用率降低；由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚拟地址和实存地址的最低若干二进制位作为段内地址，并与段号进行直接拼接，必须用加法操作通过段起址与段内地址的求和运算得到物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。|
    |段页式管理|它提供了大量的虚拟存储空间； 能有效地利用主存，为组织多道程序运行提供了方便。|增加了硬件成本、系统的复杂性和管理上的开消；存在着系统发生抖动的危险；存在着内碎片；还有各种表格要占用主存空间。|






+ **<font size = 5>页面置换算法</font>**


    在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当缺页中断时，如果操作系统中内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移除内存，以便为即将调入的页面让出空间。主要包括有以下几种页面置换算法

    -   **最佳置换算法（OPT）**：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。于所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。(**理想情况下的页面置换算法，但是实际上不可能实现**) 
    -   **先进先出置换算法**：是最简单的页面置换算法。这种算法的基本思想是：当需要淘汰一个页面时，总是选择驻留主存时间最长的页面进行淘汰，即先进入主存的页面先淘汰。其理由是：最早调入主存的页面不再被使用的可能性最大。 
    -   **最近最久未使用算法**：这种算法的基本思想是：利用局部性原理，根据一个作业在执行过程中过去的页面访问历史来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。所以，这种算法的实质是：当需要淘汰一个页面时，总是选择在最近一段时间内最久不用的页面予以淘汰。
    -   **时钟置换算法**：简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。


+ **<font size = 5>什么是协程？</font>**

    协程是一种比线程更加轻量级的存在，一个线程可以有多个协程。协程不被操作系统内核所管理，完全由程序所控制，不会像线程切换那样消耗资源。协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。

    ![avatar](./imgs/coroutines.jpg)

+   **<font size = 5>线程的同步方式</font>**

    -   互斥锁：多个进程(线程)均可以访问到一个互斥量，通过对互斥量加锁，从而来保护一个临界区,防止其它进程(线程)同时进入临界区，保护临界资源互斥访问

    -   条件变量：条件变量适合多个进程(线程)等待同一事件发生，然后去干某事。举一个简单的例子：生产者和消费者模型：多个消费者去等待生产者生产物品，消费者去消耗物品。当生产者生产出来一件物品时，便可以通知所有的消费者(当然也可以只通知其中一个等待的消费者)---可以去消耗物品了。这时多个消费者便去争抢物品，谁快谁拿到物品消耗。当物品被消耗完时，消费者就等待生产者。就类似于这样的场景。条件变量必须配合互斥量一起工作。为什么？因为生产者生产出来的物品是临界资源，即所有进程和线程都可以使用的公共资源，则在一个时刻仅允许一个消费者去取。这时便使用互斥量去保护临界资源

    -   读写锁：读写锁适合于使用在读操作多，写操作少的情况，比如数据库。读写锁读锁可以同时加很多，但是写锁是互斥的。当有进程或者线程要写时，必须等待所有的读进程或者线程都释放自己的读锁方可以写。数据库很多时候可能只是做一些查询。

    -   信号量：在生产者消费者模型中，对任务数量的记录就可以使用信号量来做。可以理解为带计数的条件变量。当信号量的值小于0时，工作进程或者线程就会阻塞，等待物品到来。当生产者生产一个物品，会将信号量值加1操作。 这是会唤醒在信号量上阻塞的进程或者线程，它们去争抢物品。
