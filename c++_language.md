+ **c++ 内存分配方式**

    在c++中内存分为五个区，**堆**，**栈**，**自由存储区**，**全局/静态存储区**和**常量存储区**
    
    | c++内存区域| 描述 | 
    | :----------| :--------- | 
    | 堆 | 由malloc分配的内存块，它们的释放编译器不管，需要我们**主动释放**（free）。如果程序结束的时候，分配的内存块都还没有被释放，操作系统会自动回收 | 
    | 栈 | 执行函数时，函数内部的局部变量在栈上创建，函数执行完时，这些存储单元**自动释放**，栈的分配内置于处理器的指令集中，效率高，但是分配的内容容量有限 | 
    | 自由存储区| 是由new分配的内存块，和堆比较相似，但是使用delete释放内存|
    | 全局/静态存储区| 全局变量和静态变量分配到同一内存块中|
    | 常量存储区| 存储常量，不可被修改|

+ **malloc/free 和 new/delet的区别**

    主要分为以下几个方面的区别
    
    1.  new/delete是c++关键字，malloc/free是库函数，需要头文件支持
    2.  malloc声明的时候需要显式地指出内存所需的大小，new无需指示分配的内存大小，编译器会根据类型自行计算
    3.  malloc内存分配成功时，返回的是void*指针，需要强制类型转换转成需要的类型。new分配内存成功时，返回的指针和对象类型严格匹配
    4.  malloc内存分配失败时，返回NULL指针，new内存分配失败时，会抛出bac_alloc异常
    5.  new/delete允许重载，mmalloc不允许
    6.  new/delete会调用构造函数和析构函数，而malloc/free不会。使用new时会先分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象，然后编译器运行相应的构造函数来构造对象，并为其传入初值，对象构造完成返回该对象指针; delete则是先调用对象的析构函数，编译器再调用delete释放内存空间;使用malloc时不会调用构造函数。
    7.  malloc能够直观地分配内存，再malloc使用过程中发现n内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前指针是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针，如果空间不够，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域；new没有直观的配套设施来扩充内存


+ **extern的用法**

    extern可以放在函数或者变量前面，表示变量或者函数的定义在别的文件中，提示编译器在其它模块寻找它的定义。用法主要有两个
    
    1.  和“C”连用，extern “C” void func(int,int),告诉编译器在编译func这个函数时按照C的规则去翻译函数名（C++函数编译时会把函数参数的数据类型也加进去，考虑到函数重载的问题，可能会是func_int_int这种形式，但是C中不会）。
    2.  当extern 用来修饰变量时，比如extern int var, 它表示声明该变量定义在全局中，可以被本模块或者其它模块调用

+ **static用法**

    1.  static的隐藏作用，当编译多个文件时，未被static修饰的全局变量和函数都有全局可见性，在不同文件中可以通过static对变量隐藏，不同文件中定义同名函数和同名变量，不要担心命名冲突
    2.  static保持内容的持久化
    3.  初始化为0
    4.  类的静态成员函数属于整个类而非类的对象，没有this指针，因而只能访问类的静态成员和静态成员函数

+ **define和const的区别**

    define是**宏定义**，程序在预处理阶段将用define定义的内容进行替换，因此程序运行时，常量表中并没有用define定义的常量，**系统不为它分配内存**；const定义的常量，在程序运行时在常量表中，系统为它分配内存。define编译时不进行数据类型检查

+ **引用和指针的区别**

    首先给出引用的定义，引用是对变量起的一个别名，并没有重新定义一个变量；而指针是某个变量的地址，概括如下
    1.  都和地址有关，指针更加自由，引用更加安全
    2.  指针是一个变量，引用是一个变量的别名
    3.  引用只能被初始化一次，而指针变量可以随意改变
    4.  sizeof（引用）是指所指向变量的大小，而指针是**4**字节


+ **野指针，指针悬挂是什么意思**

    **野指针**：指向不可用内存区域的指针
    
    **指针悬挂**：指向该地址的指针突然指向了别的地方，但是改变这个指向之前并没有对该地址里面的内容撤销，导致该内存区域的数据没法被使用但是却一直存在，造成内存泄漏

+ **虚函数内部实现**




+ **函数指针**

+ **重写，重载和重定义分别是什么意思**

+ **拷贝构造函数为什么要加引用**

+ **内联函数**

+ **c++智能指针**
